<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nim各种pragma使用方法</title>

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- CSS -->
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<!-- JS -->
<script type="text/javascript" src="dochack.js"></script>
</head>
<body>
  <div class="document" id="documentId">
    <div class="container">
      <h1 class="title">Nim各种pragma使用方法</h1>
      
<h4 id="pragmas-编译指示">Pragmas(编译指示)</h4><p>编译指示&quot;{.&quot;为开始, &quot;.}&quot;为结束, &quot;,&quot;号为分隔符, 例如{.cdecl, importc.}</p>

<h5 id="deprecated-pragma-弃用-分解qmark-指示">deprecated pragma (弃用(分解?)指示)</h5><p>deprecated指示用来标记为弃用.</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span> <span class="Identifier">char</span></pre> 也可以在声明时使用, 需要定义一个重命名列表.</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">File</span> <span class="Operator">=</span> <span class="Keyword">object</span>
  <span class="Identifier">Stream</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deprecated</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Identifier">TFile</span><span class="Punctuation">:</span> <span class="Identifier">File</span><span class="Punctuation">,</span> <span class="Identifier">PStream</span><span class="Punctuation">:</span> <span class="Identifier">Stream</span><span class="Punctuation">]</span><span class="Operator">.</span><span class="Punctuation">}</span></pre> ##### noSideEffect pragma (无副作用指示) noSideEffect指示用于标记proc(函数)/iterator(迭代器)为无副作用, 好象是在该函数里使用影响效率的函数或者修改某些变量内容就会出错, 如echo 未来的发展方向: func可能成为无副作用函数的关键字或语法糖(就是说以后更新正式版可能会加入func这个关键字来声明无副作用函数.)</p>
<p><pre class="listing">
<span class="Keyword">func</span> <span class="Punctuation">`</span><span class="Operator">+</span><span class="Punctuation">`</span> <span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span></pre> ##### procvar pragma(过程变量指示) procvar指示用于标记函数, 让它可以被传递给一个过程(函数)变量.</p>

<h5 id="compiletime-pragma-编译时指示">compileTime pragma(编译时指示)</h5><p>compileTime指示标记的函数和变量仅能在编译时使用, 不会生成代码, 辅助宏来使用.</p>

<h5 id="noreturn-pragma-无返回值指示">noReturn pragma(无返回值指示)</h5><p>noReturn标记函数没有返回值.</p>

<h5 id="discardable-pragma-丢弃返回值指示">discardable pragma(丢弃返回值指示)</h5><p>使用discardable标记的函数可以不写返回值或discard.</p>

<h5 id="noinit-pragma-无初始化指示">noInit pragma(无初始化指示)</h5><p>使用该指示的变量不会被初始化.</p>

<h5 id="requiresinit-pragma-显式初始化指示">requiresInit pragma(显式初始化指示)</h5><p>使用该指示的变量需显式的初始化.</p>
<p><pre class="listing">
<span class="Keyword">type</span>
    <span class="Identifier">MyObject</span> <span class="Operator">=</span> <span class="Keyword">object</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">requiresInit</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
    <span class="Comment"># the following is valid:</span>
    <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">MyObject</span>
    <span class="Keyword">if</span> <span class="Identifier">someCondition</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
        <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Keyword">else</span><span class="Punctuation">:</span>
        <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">b</span><span class="Punctuation">(</span><span class="Punctuation">)</span>
    <span class="Identifier">use</span> <span class="Identifier">x</span></pre></p>

<h5 id="acyclic-pragma-非周期指示">acyclic pragma(非周期指示)</h5><p>acyclic指示用来标记那些看起来周期循环(其实就是递归使用自身的类型, 像链表什么的)的object(类似c++类)类型为非周期类型, 主要是为了优化效率不让GC(垃圾处理)把这种类型的对象当循环周期部分来处理.</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">acyclic</span><span class="Punctuation">,</span> <span class="Identifier">final</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">left</span><span class="Punctuation">,</span> <span class="Identifier">right</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre> 这个例子把node类型定义为一个树结构, 注意像这种定义为递归的类型 GC会假设这种类型会形成一个周期图, 使用acyclic指示的话 GC将会无视它, 如果你把acyclic指标用于真正的循环周期类型, GC将造成内存泄漏, 当然不会有其它更糟糕的情况(我觉得内存泄漏就很糟糕拉:). 未来的发展方向: acyclic将成为ref类型属性.</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">Node</span> <span class="Operator">=</span> <span class="Identifier">acyclic</span> <span class="Keyword">ref</span> <span class="Identifier">NodeObj</span>
  <span class="Identifier">NodeObj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">left</span><span class="Punctuation">,</span> <span class="Identifier">right</span><span class="Punctuation">:</span> <span class="Identifier">Node</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">string</span></pre></p>

<h5 id="final-pragma-最终指示">final pragma(最终指示)</h5><p>类似于c++11的final关键字功能, 其实就是说这个类型不能被继承.</p>

<h5 id="shallow-pragma-浅拷贝指示">shallow pragma(浅拷贝指示)</h5><p>浅拷贝指示影响类型的语义让编译器允许浅拷贝, 这可能会导致严重的语义问题打破内存安全, 然而, 它可以非常快速的完成作业, 因为nim的语义要求深拷贝序列(seq)和字符串(string), 这是非常费时的, 特别是用序列来建立一个树结构.</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">NodeKind</span> <span class="Operator">=</span> <span class="Keyword">enum</span> <span class="Identifier">nkLeaf</span><span class="Punctuation">,</span> <span class="Identifier">nkInner</span>
  <span class="Identifier">Node</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">final</span><span class="Punctuation">,</span> <span class="Identifier">shallow</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Keyword">case</span> <span class="Identifier">kind</span><span class="Punctuation">:</span> <span class="Identifier">NodeKind</span>
    <span class="Keyword">of</span> <span class="Identifier">nkLeaf</span><span class="Punctuation">:</span>
      <span class="Identifier">strVal</span><span class="Punctuation">:</span> <span class="Identifier">string</span>
    <span class="Keyword">of</span> <span class="Identifier">nkInner</span><span class="Punctuation">:</span>
      <span class="Identifier">children</span><span class="Punctuation">:</span> <span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">Node</span><span class="Punctuation">]</span></pre></p>

<h5 id="pure-pragma-抽象指示">pure pragma(抽象指示)</h5><p>对象(object)类型可标记抽象指示, 以便该类型字段在运行时省略类型识别, 主要是为了二进制兼容其它编译语言. 也可以标记一个枚举(enum)类型, 之后必须写完整才能访问其字段.</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">valueA</span><span class="Punctuation">,</span> <span class="Identifier">valueB</span><span class="Punctuation">,</span> <span class="Identifier">valueC</span><span class="Punctuation">,</span> <span class="Identifier">valueD</span>

<span class="Identifier">echo</span> <span class="Identifier">valueA</span> <span class="Comment"># 错误, 必须类型字段写完整.</span>
<span class="Identifier">echo</span> <span class="Identifier">MyEnum</span><span class="Operator">.</span><span class="Identifier">valueA</span> <span class="Comment"># 正确</span></pre></p>

<h5 id="asmnostackframe-pragma-无堆栈帧汇编指示">asmNoStackFrame pragma(无堆栈帧汇编指示)</h5><p>函数(proc)可标记asmNoStackFrame指示告诉编译器该函数不生成堆栈帧, 也没有退出声明 如return返回值, 其生成的函数为C语言的 __declspec(naked)或__attribute__((naked))属性函数(取决于使用的C语言编译器). 注意: 这个指示只能在该函数里使用汇编语句.</p>

<h5 id="error-pragma-错误指示">error pragma(错误指示)</h5><p>error指示标记用于使编译器输出一个错误消息的内容, 使其在编译发生错误时不一定会终止. error指示也可以用来标注一个符号(如一个迭代器(iterator)或函数(proc)), 如果使用符号则发出一个编译时错误, 对于排除那些有效的重载和类型转换的操作是非常有用的.</p>
<p><pre class="listing">
<span class="Comment">#### 如果使用这个函数就会弹出编译时错误.</span>
<span class="Keyword">proc</span> <span class="Punctuation">`</span><span class="Operator">==</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">,</span> <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Keyword">ptr</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">error</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h5 id="fatal-pragma-致命指示">fatal pragma(致命指示)</h5><p>fatal指示标记用于使编译器输出一个错误消息的内容, 相对于error指示, fatal指示放哪就在哪里出错.</p>
<p><pre class="listing">
<span class="Keyword">when</span> <span class="Keyword">not</span> <span class="Identifier">defined</span><span class="Punctuation">(</span><span class="Identifier">objc</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">fatal</span><span class="Punctuation">:</span> <span class="StringLit">&quot;Compile this program with the objc command!&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h5 id="warning-pragma-警告指示">warning pragma(警告指示)</h5><p>warning指示标记用于使编译器输出一个警告消息的内容, 警告后继续编译.</p>

<h5 id="hint-pragma-提示指示">hint pragma(提示指示)</h5><p>hint指示标记用于使编译器输出一个提示消息的内容, 提示后继续编译.</p>

<h5 id="line-pragma-行指示">line pragma(行指示)</h5><p>line指示标记可以影响注释语言在堆栈回溯跟踪时的可见信息.</p>
<p><pre class="listing">
<span class="Keyword">template</span> <span class="Identifier">myassert</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">cond</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">,</span> <span class="Identifier">msg</span> <span class="Operator">=</span> <span class="StringLit">&quot;&quot;</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Keyword">not</span> <span class="Identifier">cond</span><span class="Punctuation">:</span>
    <span class="Comment"># change run-time line information of the 'raise' statement:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">line</span><span class="Punctuation">:</span> <span class="Identifier">InstantiationInfo</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span><span class="Punctuation">:</span>
      <span class="Keyword">raise</span> <span class="Identifier">newException</span><span class="Punctuation">(</span><span class="Identifier">EAssertionFailed</span><span class="Punctuation">,</span> <span class="Identifier">msg</span><span class="Punctuation">)</span></pre> 如果行指示想使用参数, 则参数需为一个元组(tuple <a class="reference internal" href="#">filename: string, line: int</a>), 如果无参, 则须使用system.InstantiationInfo()函数.</p>

<h5 id="linearscanend-pragma-直线扫描到最后qmark">linearScanEnd pragma(直线扫描到最后?)</h5><p>linearScanEnd指示用来告诉编译器如何编译case语句, 须在case语句里声明:</p>
<p><pre class="listing">
<span class="Keyword">case</span> <span class="Identifier">myInt</span>
<span class="Keyword">of</span> <span class="DecNumber">0</span><span class="Punctuation">:</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;most common case&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">1</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">linearScanEnd</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;second most common case&quot;</span>
<span class="Keyword">of</span> <span class="DecNumber">2</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;unlikely: use branch table&quot;</span>
<span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">echo</span> <span class="StringLit">&quot;unlikely too: use branch table for &quot;</span><span class="Punctuation">,</span> <span class="Identifier">myInt</span></pre> 个人理解可能是在使用case语言里的某个分支使用了linearScanEnd指示就会让该分支之上所有分支的时间效率为O(1), 具体不是很懂, 请参考原句<a class="reference external" href="http://nim-lang.org/docs/manual.html#pragmas-linearscanend-pragma">linearScanend pragma</a>, 懂的请帮忙解惑留言.</p>

<h5 id="computedgoto-pragma-跳转计算指示">computedGoto pragma(跳转计算指示)</h5><p>computedGoto指示用来告诉编译器在while循环里如何编译case语句, 须在循环内声明:</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">MyEnum</span> <span class="Operator">=</span> <span class="Keyword">enum</span>
    <span class="Identifier">enumA</span><span class="Punctuation">,</span> <span class="Identifier">enumB</span><span class="Punctuation">,</span> <span class="Identifier">enumC</span><span class="Punctuation">,</span> <span class="Identifier">enumD</span><span class="Punctuation">,</span> <span class="Identifier">enumE</span>

<span class="Keyword">proc</span> <span class="Identifier">vm</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">instructions</span><span class="Punctuation">:</span> <span class="Identifier">array</span> <span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">100</span><span class="Punctuation">,</span> <span class="Identifier">MyEnum</span><span class="Punctuation">]</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">2</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumC</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">3</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumD</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">4</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumA</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">5</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumD</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">6</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumC</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">7</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumA</span>
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">8</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumB</span>
  
  <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="DecNumber">12</span><span class="Punctuation">]</span> <span class="Operator">=</span> <span class="Identifier">enumE</span>
  <span class="Keyword">var</span> <span class="Identifier">pc</span> <span class="Operator">=</span> <span class="DecNumber">0</span>
  <span class="Keyword">while</span> <span class="Identifier">true</span><span class="Punctuation">:</span>
    <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">computedGoto</span><span class="Operator">.</span><span class="Punctuation">}</span>
    <span class="Keyword">let</span> <span class="Identifier">instr</span> <span class="Operator">=</span> <span class="Identifier">instructions</span><span class="Punctuation">[</span><span class="Identifier">pc</span><span class="Punctuation">]</span>
    <span class="Keyword">case</span> <span class="Identifier">instr</span>
    <span class="Keyword">of</span> <span class="Identifier">enumA</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah A&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumC</span><span class="Punctuation">,</span> <span class="Identifier">enumD</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah CD&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumB</span><span class="Punctuation">:</span>
      <span class="Identifier">echo</span> <span class="StringLit">&quot;yeah B&quot;</span>
    <span class="Keyword">of</span> <span class="Identifier">enumE</span><span class="Punctuation">:</span>
      <span class="Keyword">break</span>
    <span class="Identifier">inc</span><span class="Punctuation">(</span><span class="Identifier">pc</span><span class="Punctuation">)</span>

<span class="Identifier">vm</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre> 如例如示computedGoto非常适合作为解释器来使用, 如果使用的C语言编译器不支持跳转计算扩展功能 该指示将被忽略.</p>

<h5 id="immediate-pragma-立即指示">immediate pragma(立即指示)</h5><p>immediate指示用于使模板不参与重载解析, 可以在参数调用前不检查语义, 所以可以接收未声明的标识符.</p>
<p><pre class="listing">
<span class="Comment">### 普通模板</span>
<span class="Keyword">template</span> <span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 错误: 未知的标识符: 'x'</span>

<span class="Comment">###立即指示的模板</span>
<span class="Keyword">template</span> <span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">expr</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">immediate</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Identifier">declareInt</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">)</span> <span class="Comment"># 正确</span></pre></p>

<h5 id="compilation-option-pragmas-编译选项指示">compilation option pragmas(编译选项指示)</h5><p>这些列出的指示可以用来覆盖proc/method/converter的代码生成选项. 目前实现了下列选项(以后可能添加更多的选项)</p>
<table border="1" class="docutils"><tr><th>编译指示</th><th>可用值</th><th>描述</th></tr>
<tr><td>checks</td><td>on/off</td><td>代码生成时是否打开运行时检测</td></tr>
<tr><td>boundChecks</td><td>on/off</td><td>代码生成时是否检测数组边界</td></tr>
<tr><td>overflowChecks</td><td>on/off</td><td>代码生成时是否检测下溢和溢出</td></tr>
<tr><td>nilChecks</td><td>on/off</td><td>代码生成时是否检测nil指针</td></tr>
<tr><td>assertions</td><td>on/off</td><td>代码生成时断言是否生效</td></tr>
<tr><td>warnings</td><td>on/off</td><td>是否打开编译器的警告消息</td></tr>
<tr><td>hints</td><td>on/off</td><td>是否打开编译器的提示消息</td></tr>
<tr><td>optimization</td><td>none/speed/size</td><td>优化代码的速度或大小, 或关闭优化功能</td></tr>
<tr><td>patterns</td><td>on/off</td><td>是否打开改写术语的模板和宏?</td></tr>
<tr><td>callconv</td><td>cdecl/stdcall/...</td><td>对所有的函数(proc)和函数类型(proc type)指定默认的调用协议</td></tr>
</table><p>示例:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">checks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Punctuation">,</span> <span class="Identifier">optimization</span><span class="Punctuation">:</span> <span class="Identifier">speed</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Comment">### 编译时不会进行运行时检测(checks)和速度优化(optimization)</span></pre></p>

<h5 id="push-and-pop-pragmas-推入slash弹出指示">push and pop pragmas(推入/弹出指示)</h5><p>这两个指示需成对使用, 功能类似于选项指示, 作用是临时覆盖那些设置, 例如:</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">push</span> <span class="Identifier">checks</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># 保存旧的设置</span>
<span class="Comment">### 编译push/pop区域内的代码时不进行运行时检测.</span>
<span class="Comment">### speed critical</span>
<span class="Comment">### ... 一些代码 ...</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pop</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># 恢复旧的设置</span></pre></p>

<h5 id="register-pragma-寄存器指示">register pragma(寄存器指示)</h5><p>寄存器指示只能用于变量, 它会声明一个寄存器变量, 告诉编译器该变量应该使用硬件寄存器来提供更快的访问速度, C语言编译器经常会忽略这个功能, 因为它优化的比你快. 在高度特定的情况下(例如字节码解释器的消息循环)可能会更有效率, 虽然一般没什么卵用。</p>

<h5 id="global-pragma-全局指示">global pragma(全局指示)</h5><p>global指示类似于c/c++的static关键字功能, 在函数(proc)里使用变量加上global指示可一直使用此变量, 该变量只会在程序运行时初始化一次.</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">isHexNumber</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">bool</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">pattern</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">global</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="RawData">re&quot;[0-9a-fA-F]+&quot;</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">s</span><span class="Operator">.</span><span class="Identifier">match</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">)</span></pre> 每个函数(proc)里的global变量只相对该函数是唯一的, 其它函数里global变量同名不受影响.</p>

<h5 id="deadcodeelim-pragma-死代码消除">deadCodeElim pragma(死代码消除)</h5><p>deadCodeElim指示只应用于整个模块, 它告诉编译器是否对模块激活死代码消除功能. 在编译时加上--deadCodeElim:on命令时, 所有模块都带有{.deadCodeElim:on}死码消功能.</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">deadCodeElim</span><span class="Punctuation">:</span> <span class="Identifier">on</span><span class="Operator">.</span><span class="Punctuation">}</span></pre></p>

<h5 id="pragma-pragma-pp指示">pragma pragma(pp指示)</h5><p>pp指示可以用来声明用户定义的指示, 这非常有用, 因为模板和宏不会影响指示, 它们不能从模块导入.</p>
<p><pre class="listing">
<span class="Keyword">when</span> <span class="Identifier">appType</span> <span class="Operator">==</span> <span class="StringLit">&quot;lib&quot;</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Punctuation">:</span> <span class="Identifier">rtl</span><span class="Punctuation">,</span> <span class="Identifier">exportc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">,</span> <span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Keyword">else</span><span class="Punctuation">:</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">pragma</span><span class="Punctuation">:</span> <span class="Identifier">rtl</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;client.dll&quot;</span><span class="Punctuation">,</span> <span class="Identifier">cdecl</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">rtl</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">a</span><span class="Operator">+</span><span class="Identifier">b</span></pre> 在这个例子中一个被命名为rtl的指示可以从任意动态库中导入其中的符号(函数或变量)或为动态库生成导出符号.</p>

<h5 id="disabling-certain-messages-禁止某些消息">Disabling certain messages(禁止某些消息)</h5><p>某些用户可能不喜欢nim生成的一些很长的警告和提示, 可用它来关闭那些警告和提示.</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">hint</span><span class="Punctuation">[</span><span class="Identifier">LineTooLong</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">off</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Comment"># 禁止太长的提示.</span></pre> 比挨个设置禁止不同的警告要方便多了.</p>

<h5 id="experimental-pragma-实验性指示">experimental pragma(实验性指示)</h5><p>让你可以使用那些实验性的语言功能, 这些不稳定的功能可能会在出现在未来的稳定版中也有可能永远删除, 喜欢尝鲜的小白鼠可以一试.</p>
<p><pre class="listing">
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">experimental</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">useUsing</span><span class="Punctuation">(</span><span class="Identifier">dest</span><span class="Punctuation">:</span> <span class="Keyword">var</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">using</span> <span class="Identifier">dest</span>
  <span class="Identifier">add</span> <span class="StringLit">&quot;foo&quot;</span>
  <span class="Identifier">add</span> <span class="StringLit">&quot;bar&quot;</span></pre></p>

<h5 id="foreign-function-interface-外部函数接口">Foreign function interface(外部函数接口)</h5><p>Nim的外部函数接口是非常广泛的, 只有部分未来扩展的后端(如LLVM/Javascript)记录在这里.</p>

<h5 id="importc-pragma-c语言导入指示">Importc pragma(C语言导入指示)</h5><p>该指示表示从外部文件导入符号(函数或变量)</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">header</span><span class="Punctuation">:</span> <span class="StringLit">&quot;&lt;stdio.h&gt;&quot;</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">:</span> <span class="StringLit">&quot;printf&quot;</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span></pre> 上面是导入C语言的符号, 如果想导入C++的就是importcpp, objc的就是importobjc.</p>

<h5 id="exportc-pragma-c语言导出指示">Exportc pragma(C语言导出指示)</h5><p>与importc的功能相反, 主要是作为库导出符号让人调用.</p>
<p><pre class="listing">
<span class="Comment">###fib.nim</span>
<span class="Keyword">proc</span> <span class="Identifier">fib</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">cint</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">cint</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">exportc</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">if</span> <span class="Identifier">a</span> <span class="Operator">&lt;=</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Keyword">else</span><span class="Punctuation">:</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Identifier">fib</span><span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">-</span> <span class="DecNumber">1</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">fib</span><span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">-</span> <span class="DecNumber">2</span><span class="Punctuation">)</span></pre></p>
<p><pre class="listing">
<span class="Comment">//maths.c</span>
<span class="Preprocessor">#</span><span class="Preprocessor">#</span><span class="Preprocessor">#include</span> <span class="StringLit">&quot;fib.h&quot;</span>
<span class="Preprocessor">#</span><span class="Preprocessor">#</span><span class="Preprocessor">#include</span> <span class="Operator">&lt;</span><span class="Identifier">stdio</span><span class="Punctuation">.</span><span class="Identifier">h</span><span class="Operator">&gt;</span>

<span class="Keyword">int</span> <span class="Identifier">main</span><span class="Punctuation">(</span><span class="Keyword">void</span><span class="Punctuation">)</span>
<span class="Punctuation">{</span>
  <span class="Identifier">NimMain</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
  <span class="Keyword">for</span> <span class="Punctuation">(</span><span class="Keyword">int</span> <span class="Identifier">f</span> <span class="Operator">=</span> <span class="DecNumber">0</span><span class="Punctuation">;</span> <span class="Identifier">f</span> <span class="Operator">&lt;</span> <span class="DecNumber">10</span><span class="Punctuation">;</span> <span class="Identifier">f</span><span class="Operator">++</span><span class="Punctuation">)</span>
    <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="StringLit">&quot;Fib of %d is %d</span><span class="EscapeSequence">\n</span><span class="StringLit">&quot;</span><span class="Punctuation">,</span> <span class="Identifier">f</span><span class="Punctuation">,</span> <span class="Identifier">fib</span><span class="Punctuation">(</span><span class="Identifier">f</span><span class="Punctuation">)</span><span class="Punctuation">)</span><span class="Punctuation">;</span>
  <span class="Keyword">return</span> <span class="DecNumber">0</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span></pre> 直接编译要加入nimcache目录</p>
<p><pre class="listing">
&gt; nim c --noMain --noLinking --header:fib.h fib.nim
&gt; gcc -o m -Inimcache -Ipath/to/nim/lib nimcache/*.c maths.c</pre> 也可以编译成静态库给c/c++用, linux下可能要加-ldl</p>
<p><pre class="listing">
&gt; nim c --app:staticLib --noMain --header fib.nim
&gt; gcc -o m -Inimcache -Ipath/to/nim/lib libfib.nim.a maths.c</pre> 也可以编译成javascript给html用.</p>
<p><pre class="listing">
&lt;html&gt;&lt;body&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;fib.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
alert(&quot;Fib for 9 is &quot; + fib(9));
&lt;/script&gt;
&lt;/body&gt;&lt;/html&gt;</pre></p>
<p><pre class="listing">
nim js -o:fib.js fib.nim</pre> 详细内容请参考:<a class="reference external" href="http://nim-lang.org/docs/backends.html">backends</a></p>

<h5 id="extern-pragma-外部指示">Extern pragma(外部指示)</h5><p>类似importc或exportc, extern指示会影响名字识别, 字符串转给extern可以是格式字符串.</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">p</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">string</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">extern</span><span class="Punctuation">:</span> <span class="StringLit">&quot;prefix$1&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">s</span></pre> 例中把p设为外部名prefix$1(1参数), 类似于win的函数符号协议.</p>

<h5 id="bycopy-pragma-被复制指示">Bycopy pragma(被复制指示)</h5><p>Bycopy该指示可应用于对象和元组, 通过编译器把类型的值转给函数(proc).</p>

<h5 id="byref-pragma-被引用指示">Byref pragma(被引用指示)</h5><p>Byref指示可应用于对象和元组, 通过编译器把该类型作为引用传给函数.</p>

<h5 id="varargs-pragma-可变参数指示">Varargs pragma(可变参数指示)</h5><p>varargs指示可以让使用的函数(proc)最后一个参数转变为可变参数(类似c语言printf的fmt), 这个函数使用的nim字符串会自动转换为cstring.</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">printf</span><span class="Punctuation">(</span><span class="Identifier">formatstr</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">nodecl</span><span class="Punctuation">,</span> <span class="Identifier">varargs</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Identifier">printf</span><span class="Punctuation">(</span><span class="StringLit">&quot;hallo %s&quot;</span><span class="Punctuation">,</span> <span class="StringLit">&quot;world&quot;</span><span class="Punctuation">)</span> <span class="Comment"># &quot;world&quot; 将转换为cstring</span></pre></p>

<h5 id="union-pragma-联合指示">Union pragma(联合指示)</h5><p>union看起来像c++的union用法, 可应用于任何对象(object)类型, 共享字段, 暂不支持GC和继承. 未来发展的方向: 将允许GC检测和控制内存.</p>

<h5 id="packed-pragma-封包指示">Packed pragma(封包指示)</h5><p>packed指示可应用于任何对象(object)类型, 它确保对象的字段头尾相接连续保存在一段内存内, 这适用于网络包传输和硬件驱动, 封包指示目前还不能使用继承和GC管理内存. 未来发展的方向: 将支持继承, 如果封闭的内部有使用gc的话将会在编译时提示错误.</p>

<h5 id="unchecked-pragma-无检测指示">Unchecked pragma(无检测指示)</h5><p>Unchecked指示可以让该数组不对边界检测, 这个非常有用, 适合在你想要一个灵活大小却又不确定大小的数组时使用.</p>
<p><pre class="listing">
<span class="Keyword">type</span>
  <span class="Identifier">ArrayPart</span><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">unchecked</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Identifier">array</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="DecNumber">0</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span>
  <span class="Identifier">MySeq</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">len</span><span class="Punctuation">,</span> <span class="Identifier">cap</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">ArrayPart</span></pre> 类似C语言的这个代码.</p>
<p><pre class="listing">
<span class="Keyword">typedef</span> <span class="Keyword">struct</span> <span class="Punctuation">{</span>
  <span class="Identifier">NI</span> <span class="Identifier">len</span><span class="Punctuation">;</span>
  <span class="Identifier">NI</span> <span class="Identifier">cap</span><span class="Punctuation">;</span>
  <span class="Identifier">NI</span> <span class="Identifier">data</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">;</span>
<span class="Punctuation">}</span> <span class="Identifier">MySeq</span><span class="Punctuation">;</span></pre> 无检测的数组类型没有GC内存管理. 未来的发展方向: 无检测的数组将支持GC内存管理.</p>

<h5 id="dynlib-pragma-for-import-动态库的导入指示">Dynlib pragma for import(动态库的导入指示)</h5><p>dynlib指示可结合importc指示从动态链接库里导入符号(函数,变量等)(.dll是win的, .so是linux/unix的动态库扩展名)</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">gtk_image_new</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PGtkWidget</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;libgtk-x11-2.0.so&quot;</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Operator">.</span><span class="Punctuation">}</span></pre> 同样支持版本控制.</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">Tcl_Eval</span><span class="Punctuation">(</span><span class="Identifier">interp</span><span class="Punctuation">:</span> <span class="Identifier">pTcl_Interp</span><span class="Punctuation">,</span> <span class="Identifier">script</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span>
  <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="StringLit">&quot;libtcl(|8.5|8.4|8.3).so.(1|0)&quot;</span><span class="Operator">.</span><span class="Punctuation">}</span></pre> 运行时会依照这个循序搜索动态库文件.</p>
<p><pre class="listing">
libtcl.so.1
libtcl.so.0
libtcl8.5.so.1
libtcl8.5.so.0
libtcl8.4.so.1
libtcl8.4.so.0
libtcl8.3.so.1
libtcl8.3.so.0</pre> 动态库导入不仅支持常数字符串, 同样支持一般的字符串表达式.</p>
<p><pre class="listing">
<span class="Keyword">import</span> <span class="Identifier">os</span>

<span class="Keyword">proc</span> <span class="Identifier">getDllName</span><span class="Punctuation">:</span> <span class="Identifier">string</span> <span class="Operator">=</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;mylib.dll&quot;</span>
  <span class="Keyword">if</span> <span class="Identifier">existsFile</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="StringLit">&quot;mylib2.dll&quot;</span>
  <span class="Keyword">if</span> <span class="Identifier">existsFile</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">return</span>
  <span class="Identifier">quit</span><span class="Punctuation">(</span><span class="StringLit">&quot;could not load dynamic library&quot;</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">myImport</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">:</span> <span class="Identifier">cstring</span><span class="Punctuation">)</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">importc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Punctuation">:</span> <span class="Identifier">getDllName</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre> 注意: 像libtcl(|8.5|8.4).so只支持在常数字符串, 因为它是预编译. 注意: 因为初始化循序的问题, 运行时传递变量给该指示将会失败. 注意: 动态库导入可以被 --dynlibOverride:name 命令行选项覆盖, 查看用户编译手册了解相关信息.</p>

<h5 id="dynlib-pragma-for-export-动态库的导出指示">Dynlib pragma for export(动态库的导出指示)</h5><p>dynlib指示也能能把符号导出给他人使用, 该指示没有参数且必须结合exportc指示使用.</p>
<p><pre class="listing">
<span class="Keyword">proc</span> <span class="Identifier">exportme</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">cdecl</span><span class="Punctuation">,</span> <span class="Identifier">exportc</span><span class="Punctuation">,</span> <span class="Identifier">dynlib</span><span class="Operator">.</span><span class="Punctuation">}</span></pre> 动态库导出只在程序通过命令行选项 --app:lib 编译成动态链接库才有用.</p>

<h4 id="参考资料colonnim-manualminuspragmashttpcolonslashslashnimminuslangdotorgslashdocsslashmanualdothtml-pragmas">参考资料:<a class="reference external" href="http://nim-lang.org/docs/manual.html#pragmas">nim manual-pragmas</a></h4>


      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br>
        <small style="color: var(--hint);">Made with Nim. Generated: 2023-05-28 20:28:04 UTC</small>
      </div>
    </div>
  </div>
  
</body>
</html>
